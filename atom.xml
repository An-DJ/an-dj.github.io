<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>泡壶Java</title>
  
  <subtitle>浸透人生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://andj.me/"/>
  <updated>2019-09-07T06:02:50.889Z</updated>
  <id>http://andj.me/</id>
  
  <author>
    <name>AnDJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Raft浅谈</title>
    <link href="http://andj.me/2019/09/07/Raft%E6%B5%85%E8%B0%88/"/>
    <id>http://andj.me/2019/09/07/Raft浅谈/</id>
    <published>2019-09-07T13:39:17.000Z</published>
    <updated>2019-09-07T06:02:50.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft-浅谈"><a href="#Raft-浅谈" class="headerlink" title="Raft 浅谈"></a>Raft 浅谈</h1><h2 id="分布式一致性-Distributed-Consensus"><a href="#分布式一致性-Distributed-Consensus" class="headerlink" title="分布式一致性(Distributed Consensus)"></a>分布式一致性(Distributed Consensus)</h2><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><ul><li>分布式环境：复杂，Some of the processes (agents) may fail or be unreliable in other ways</li><li>一致性：requires agreement among a number of processes (or agents) for a single data value</li><li>单个节点（数据副本）更新，所有节点数据也要相应更新。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566956207876-4391d331-854b-4838-ba0c-509fb38ad66c.png#align=left&display=inline&height=293&name=consensus.png&originHeight=293&originWidth=541&size=16535&status=done&width=541" alt="分布式一致性图示" title="">                </div>                <div class="image-caption">分布式一致性图示</div>            </figure><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><strong>Termination</strong></p><p>Eventually, every correct process decides some value.</p><p><strong>Integrity</strong> ( <em>be honest</em> )</p><p>If all the correct processes proposed the same value _v_, then any correct process must decide _v_.</p><p><strong>Agreement</strong></p><p>Every correct process must agree on the same value.</p><h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><ul><li>Leader election / Mutual Exclusion</li><li>Commit or Abort in distributed transactions</li><li>Reaching agreement about which process has failed</li><li>Clock phase synchronization</li></ul><h3 id="一致性协议-Consensus-Protocol"><a href="#一致性协议-Consensus-Protocol" class="headerlink" title="一致性协议(Consensus Protocol)"></a>一致性协议(Consensus Protocol)</h3><ul><li>2PC (Two-Phase Commit)</li><li>3PC (Three-Phase Commit)</li><li>Paxos and its variants</li><li>Chubby</li><li>ZAB (ZooKeeper Atomic Broadcast)</li><li>Raft</li><li>…</li></ul><h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><ul><li>Lamport 提出的一种基于消息传递的分布式一致性算法</li><li><em>The Part-Time Parliament, 1998</em>，首篇论文，以故事性叙述（同行表示看不懂）</li><li><em>Paxos Made Simple, 2001</em>，再篇，算法描述（表示仍然看不懂）</li><li>too difficult to understand and implement</li><li>产生了许多结合实际的衍生实现</li></ul><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><ul><li>论文: <em>In Search of an Understandable Consensus Algorithm (Extended Version)</em></li><li>基于日志复制 ( replicated log )</li><li>简单，易懂，易于实现，这是 Raft 的研究目的</li><li>Stanford 调查发现，对于学生，Raft 算法比 Paxos 更加易于学习</li><li>3 part: <strong><em>leader election, log replication, and safety</em></strong></li></ul><h3 id="复制状态机-Replicated-state-machines"><a href="#复制状态机-Replicated-state-machines" class="headerlink" title="复制状态机 Replicated state machines"></a>复制状态机 Replicated state machines</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566958856739-ad3d084f-adbb-4f9f-8b72-641feb93c79a.png#align=left&display=inline&height=247&name=Screenshot%20from%202019-08-28%2010-20-28.png&originHeight=247&originWidth=392&size=37206&status=done&width=392" alt="复制状态机" title="">                </div>                <div class="image-caption">复制状态机</div>            </figure><br><br><br>- 一致性算法管理来自客户端指令的复制日志<br>- 状态机从日志中处理相同顺序的相同指令，所以产生的结果一致<br>- 保证复制日志相同 –&gt; 保证一致性<br><br>### Raft 基础<br><br>- Raft 集群中包含若干节点，通常是5个<br>- 半数以上的节点存活，保持可用性<br>- 节点角色状态机（3种角色）<br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566959735657-020ad9e5-bd81-4799-9e6b-2b821b2c0425.png#align=left&display=inline&height=192&name=Screenshot%20from%202019-08-28%2010-35-09.png&originHeight=192&originWidth=441&size=40113&status=done&width=441" alt="role 状态机" title="">                </div>                <div class="image-caption">role 状态机</div>            </figure><ul><li>通常情况下，系统中只有一个 leader ，其他都是 follower</li><li>如果客户端与其中一个 follower，其会请求重定向</li><li>领导人任期</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566960157811-627cdd28-df0f-48ab-85f3-665535e71ba7.png#align=left&display=inline&height=169&name=Screenshot%20from%202019-08-28%2010-42-17.png&originHeight=331&originWidth=852&size=35827&status=done&width=435" alt="任期示例" title="">                </div>                <div class="image-caption">任期示例</div>            </figure><ul><li>每一段任期都是从一次选举开始，任期内 leader 唯一且发挥作用</li><li>任期是一种逻辑时钟，任期号单调增</li><li>某个 leader 发现有节点任期号比自己大？ 切换为 follower</li><li>某个请求不属于该任期处理？拒绝</li></ul><h3 id="领导选举-leader-election"><a href="#领导选举-leader-election" class="headerlink" title="领导选举 leader election"></a>领导选举 <strong>leader election</strong></h3><p>集群初始化 or 当现存的领导人宕机的时候，一个新的领导人需要被选举出来。</p><ul><li>心跳机制：候选人拉票，半数以上赞同即成为下一任 leader</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566960733697-9f454765-cc85-4a22-89ec-077da45c00d1.png#align=left&amp;display=inline&amp;height=300&amp;name=Screenshot%20from%202019-08-28%2010-51-50.png&amp;originHeight=388&amp;originWidth=408&amp;size=18629&amp;status=done&amp;width=315" alt="等待 leader">      <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566960788345-5e2216f2-2cb2-48e9-b0d8-b9c86d622a7c.png#align=left&amp;display=inline&amp;height=294&amp;name=Screenshot%20from%202019-08-28%2010-52-47.png&amp;originHeight=380&amp;originWidth=408&amp;size=20270&amp;status=done&amp;width=316" alt="S1 成为 candidate"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566960866335-7a29ab44-24f1-4788-a33a-4bc8db303615.png#align=left&amp;display=inline&amp;height=296&amp;name=Screenshot%20from%202019-08-28%2010-54-10.png&amp;originHeight=382&amp;originWidth=408&amp;size=28063&amp;status=done&amp;width=316" alt="投票且 S2 成为 candidate">      <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566960928944-efcfd092-bd34-4119-a671-9d96b29c8b59.png#align=left&amp;display=inline&amp;height=292&amp;name=Screenshot%20from%202019-08-28%2010-54-58.png&amp;originHeight=387&amp;originWidth=407&amp;size=27120&amp;status=done&amp;width=307" alt="S1 当选为 leader"></p><ul><li><strong>选举 RPC</strong>，会带有部分信息，如任期号</li><li>选举结果：自己是 leader；别的节点是 leader；超时没选出来</li><li>选举先来先服务</li><li>RPC心跳包 任期号比自己的小？不选它</li><li>没选出来怎么办？选举超时，可以再选一次</li><li>一直超时一直选怎么办？随机指定超时时间</li><li><strong>总是能选出有且只有一个 leader</strong></li></ul><h3 id="日志复制-log-replication"><a href="#日志复制-log-replication" class="headerlink" title="日志复制 log replication"></a>日志复制 <strong>log replication</strong></h3><p>一旦一个 leader 被选出来，它便可以对客户端进行服务。leader 必须从客户端接收日志然后复制到集群中的其他节点，且强制要求其他节点的日志保持和自己相同。</p><ul><li>流程：客户端发起指令日志 <br>–&gt; leader 存储日志并发送复制RPC给其他节点（通信存在问题，会不断进行尝试） <br>–&gt; 被安全复制后，leader 将其执行到自身的状态机，返回结果给客户端 <br>–&gt; 其他节点执行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566962392234-6838d5b2-0871-4bdb-ba64-6754fa4eb355.png#align=left&display=inline&height=301&name=Screenshot%20from%202019-08-28%2011-19-29.png&originHeight=505&originWidth=666&size=68848&status=done&width=397" alt="日志复制" title="">                </div>                <div class="image-caption">日志复制</div>            </figure><ul><li>日志有序号，有创建时的任期号，有操作指令</li><li>日志复制RPC，</li><li>大多数节点日志复制成功，leader 则提交，通过心跳告知其他节点执行到状态机</li><li>leader 保存跟踪最大可以提交的日志 index</li></ul><p><strong>日志匹配特性</strong></p><ul><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令</li><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同</li></ul><h4 id="leader-崩溃带来的问题"><a href="#leader-崩溃带来的问题" class="headerlink" title="leader 崩溃带来的问题"></a>leader 崩溃带来的问题</h4><p>follower 可能有当前 leader 有的条目，也可能缺少当前 leader 部分条目，也可能兼有。如下一种情况：</p><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566972043233-beeb4e33-7d42-4ab9-8826-3cf265c68fb1.png#align=left&display=inline&height=290&name=Screenshot%20from%202019-08-28%2014-00-22.png&originHeight=558&originWidth=821&size=74359&status=done&width=426" alt="leader 崩溃带来的问题" title="">                </div>                <div class="image-caption">leader 崩溃带来的问题</div>            </figure><br><br><br>可能产生这样的原因是：f 当选为 leader，写入日志后没有成功复制就崩溃了；很快 f 机器又重启了，又再次被选为 leader，写入日志后又再次崩溃了，之后是 e，等等。最终会造成上图的结果。leader 是第一行的机器，任期为8。<br><br><br><strong>解决办法</strong><br>强制 follower 直接复制 leader 的日志。</p><ul><li>leader 从日志最后一条开始往前找，一个对应其他follower的 nextIndex[] 数组维护，初始为leader尾index+1；</li><li>每次尝试写入 follower ，不一致则 nextIndex-1，直到找到一致的地方；</li><li>强制复制 leader nextIndex 到末尾的部分给 follower</li><li><strong>保证了日志匹配特性！</strong></li></ul><h3 id="安全性-safety"><a href="#安全性-safety" class="headerlink" title="安全性 safety"></a>安全性 <strong><em>safety</em></strong></h3><p>前述算法实际上并不能够充分保证每一个状态机会按照相同的顺序执行相同的指令，会存在一些问题，比如 leader 提交日志， 但某个 follower 变为不可用，之后该 follower 被选举为 leader，并且覆盖了这些日志条目。因此，可能存在不同的状态机执行不同的指令序列。</p><p>如下有<strong>两处</strong>规则限制：</p><h4 id="1-选举限制"><a href="#1-选举限制" class="headerlink" title="1. 选举限制"></a>1. 选举限制</h4><ul><li>leader 必须包含所有的已 commit 的日志</li><li>选 leader 时，必须遵循如上规则，方法是，投票人会投给与大多数节点一样“新”的节点；拒绝非新节点</li><li>新？比较条件是，两份日志最后条目任期号大的较“新”，任期号一致则日志较长的“新”</li></ul><p><strong>这里论文里没有给出更细致的说明，需要考虑的问题是，为什么这样的策略选出来的leader一定是包含所有已提交的日志的？</strong></p><ul><li>实际上确实是这样的</li></ul><h4 id="2-提交之前任期内的日志"><a href="#2-提交之前任期内的日志" class="headerlink" title="2. 提交之前任期内的日志"></a>2. 提交之前任期内的日志</h4><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.nlark.com/yuque/0/2019/png/457347/1566992314754-b2579d0f-201c-4ab1-9fd6-229c1db92786.png#align=left&display=inline&height=218&name=Screenshot%20from%202019-08-28%2019-38-16.png&originHeight=440&originWidth=953&size=72011&status=done&width=472" alt="是否提交之前任期内的日志" title="">                </div>                <div class="image-caption">是否提交之前任期内的日志</div>            </figure><br><br><br>考虑如上问题。S1作为 leader，任期为2，复制到S2后崩溃；再次选举，S5获选为leader，任期为3，写入自身日志后崩溃；再次选举，S1的末尾日志是最新的，可以获选为leader，任期为4，此时将自己的日志复制到了S3，保证了大多数节点都复制了日志。<br><br><br><strong>这里问题来了：此时S1符合commit的条件，那么到底是提交呢还是不提交？</strong></p><ul><li>如果提交，情况为d。提交后，S1崩溃，此时集群中的节点最新的节点为S5（因为尾日志任期最新），并且会进行日志复制，这样的话，就会将之前的任期为2的日志覆盖！这样的话，集群中的节点部分就会缺失term 2的操作！</li></ul><p><strong>其实，实际上需要解决的是，在leader崩溃后，S5这样的节点不能被选为leader！</strong></p><ul><li>如果不提交，情况为e。S1崩溃的话，不会发生上述问题。S1不崩溃的话，在任期4生成日志并复制到大多数节点，然后再提交，这样的话，如果此时S1崩溃，S5并不能当选（想想为什么），因此解决了问题。</li></ul><h3 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h3><ul><li>支持线性化语义</li><li>客户端请求 -&gt; 任一服务器，非 leader 则会转发</li><li>leader 崩溃？超时重发。这样会有幂等性问题（使用序列号解决）</li><li>只读的操作，可以不需要记录日志，但也会有问题：脏读（可能产生了新的 leader）</li><li>脏读解决方式：心跳 ReadIndex or 租约 lease</li><li>ReadIndex<ul><li>与其他的节点发心跳，肯定自己为 leader</li></ul></li><li>lease<ul><li>取一个小于 Election Timeout的时间作为租期</li><li>租期内不发生选举</li><li>非常依赖时间，不能有太大的误差</li></ul></li></ul><h3 id="Have-a-try"><a href="#Have-a-try" class="headerlink" title="Have a try"></a>Have a try</h3><p>动手实现Raft：<br><a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考)"></a>参考<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science" target="_blank" rel="noopener"></a>)</h2><p><a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a><br><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">https://raft.github.io/raft.pdf</a><br><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a><br><a href="https://pingcap.github.io/blog-cn/linearizability-and-raft/" target="_blank" rel="noopener">https://pingcap.github.io/blog-cn/linearizability-and-raft/</a><br><a href="http://homepage.divms.uiowa.edu/~ghosh/16612.week11.pdf" target="_blank" rel="noopener">http://homepage.divms.uiowa.edu/~ghosh/16612.week11.pdf</a><br><a href="https://en.wikipedia.org/wiki/Consensus_(computer_science" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Consensus_(computer_science)</a>)</p><p>董峻铎，于2019年8月29日，小米武汉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Raft-浅谈&quot;&gt;&lt;a href=&quot;#Raft-浅谈&quot; class=&quot;headerlink&quot; title=&quot;Raft 浅谈&quot;&gt;&lt;/a&gt;Raft 浅谈&lt;/h1&gt;&lt;h2 id=&quot;分布式一致性-Distributed-Consensus&quot;&gt;&lt;a href=&quot;#分布式一致
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://andj.me/2019/09/07/hello-world/"/>
    <id>http://andj.me/2019/09/07/hello-world/</id>
    <published>2019-09-07T05:20:46.742Z</published>
    <updated>2019-09-07T05:20:46.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用马克飞象"><a href="#欢迎使用马克飞象" class="headerlink" title="欢迎使用马克飞象"></a>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p><p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p><ul><li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li><li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="noopener">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="noopener">离线Chrome App</a>，支持移动端 Web；</li><li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li></ul><hr><p>[TOC]</p><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="noopener">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:right">Value</th><th style="text-align:center">Qty</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 USD</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 USD</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 USD</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>以及时序图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">语法</a>。</p></blockquote><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p><ul><li style="list-style: none"><input type="checkbox" checked> 已完成事项</li><li style="list-style: none"><input type="checkbox"> 待办事项1</li><li style="list-style: none"><input type="checkbox"> 待办事项2</li></ul><blockquote><p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p></blockquote><h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p><h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p><h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p><blockquote><p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p></blockquote><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p><blockquote><p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p></blockquote><h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p></blockquote><h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code> </p><p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p><h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p><h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul><li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="noopener">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="noopener">@GGock</a></li><li>邮箱：<a href="mailto:&#x68;&#x75;&#115;&#x74;&#x67;&#x6f;&#99;&#x6b;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x68;&#x75;&#115;&#x74;&#x67;&#x6f;&#99;&#x6b;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a></li></ul><hr><p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p><p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="noopener">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="noopener">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欢迎使用马克飞象&quot;&gt;&lt;a href=&quot;#欢迎使用马克飞象&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用马克飞象&quot;&gt;&lt;/a&gt;欢迎使用马克飞象&lt;/h1&gt;&lt;p&gt;@(示例笔记本)[马克飞象|帮助|Markdown]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;马克飞象
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>6.828-2018-Lecture-1:O/S overview</title>
    <link href="http://andj.me/2019/02/18/6-828-2018-Lecture-1-O-S-overview/"/>
    <id>http://andj.me/2019/02/18/6-828-2018-Lecture-1-O-S-overview/</id>
    <published>2019-02-17T18:44:13.000Z</published>
    <updated>2019-09-07T05:20:46.738Z</updated>
    
    <content type="html"><![CDATA[<p>6.828 2018 Lecture 1: O/S overview<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.828 2018 课时1:操作系统概述</span><br></pre></td></tr></table></figure></p><p>Overview<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">概述</span><br></pre></td></tr></table></figure></p><ul><li><p>6.828 goals</p><ul><li>Understand operating system design and implementation</li><li>Hands-on experience by building small O/S<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 6.828 课程目标</span><br><span class="line">* 理解操作系统的设计与实现</span><br><span class="line">* 通过构建小的操作系统来亲自动手实践</span><br></pre></td></tr></table></figure></li></ul></li><li><p>What is the purpose of an O/S?</p><ul><li>Support applications</li><li>Abstract the hardware for convenience and portability</li><li>Multiplex the hardware among multiple applications</li><li>Isolate applications in order to contain bugs</li><li>Allow sharing among applications</li><li>Provide high performance<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 操作系统的作用是什么?</span><br><span class="line">  * 支持应用运行</span><br><span class="line">  * 将硬件层抽象,提供方便和可移植性</span><br><span class="line">  * 在多个应用之间提供硬件资源复用</span><br><span class="line">  * 隔离多个应用,容许错误存在</span><br><span class="line">  * 允许应用之间共享资源</span><br><span class="line">  * 提供较高的性能</span><br></pre></td></tr></table></figure></li></ul></li><li><p>What is the O/S design approach?</p><ul><li>the small view: a h/w management library</li><li>the big view: physical machine -&gt; abstract one w/ better properties<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 操作系统设计的方法是什么?</span><br><span class="line">  * 从小的角度来看:一个硬件管理库</span><br><span class="line">  * 从大的角度来看:物理机器到有着较好的性能的抽象单元的一个映射</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Organization: layered picture<br> &emsp;h/w: CPU, mem, disk, &amp;c<br> &emsp;kernel services<br> &emsp;user applications: vi, gcc, &amp;c  </p><ul><li>we care a lot about the interfaces and internal kernel structure<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 操作系统的组织:分层图</span><br><span class="line">   硬件层:CPU(中央处理单元),内存,磁盘,等等</span><br><span class="line">   内核服务</span><br><span class="line">   用户应用层:vi,gcc,等等</span><br><span class="line">  * 我们比较关心接口和内部内核结构</span><br></pre></td></tr></table></figure></li></ul></li><li><p>What services does an O/S kernel typically provide?</p><ul><li>processes</li><li>memory allocation</li><li>file contents</li><li>directories and file names</li><li>security</li><li>many others: users, IPC, network, time, terminals<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 操作系统提供哪些有特点的服务?</span><br><span class="line">  * 进程</span><br><span class="line">  * 内存分配</span><br><span class="line">  * 文件内容</span><br><span class="line">  * 目录和文件名</span><br><span class="line">  * 安全</span><br><span class="line">  * 很多其他的服务:用户,IPC(进程间通信),网络,时间,终端.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>What does an O/S abstraction look like?</p><ul><li>Applications see them only via system calls</li><li><p>Examples, from UNIX (e.g. Linux, OSX, FreeBSD):</p><pre><code>fd = open(&quot;out&quot;, 1);write(fd, &quot;hello\n&quot;, 6);pid = fork();</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 操作系统完成的抽象是什么样子的?</span><br><span class="line">  * 应用只能通过系统调用来访问它们</span><br><span class="line">  * 例如, 在UNIX下 (比如 Linux, OSX, FreeBSD):</span><br><span class="line"></span><br><span class="line">            fd = open(&quot;out&quot;, 1);</span><br><span class="line">            write(fd, &quot;hello\n&quot;, 6);</span><br><span class="line">            pid = fork();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Why is O/S design/implementation hard/interesting?</p><ul><li>the environment is unforgiving: quirky h/w, weak debugger</li><li>it must be efficient (thus low-level?)<br>…but abstract/portable (thus high-level?)</li><li>powerful (thus many features?)<br>…but simple (thus a few composable building blocks?)</li><li>features interact: <code>fd = open(); ...; fork()</code></li><li>behaviors interact: CPU priority vs memory allocator</li><li>open problems: security; performance; exploiting new hardware<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 为什么操作系统的设计和实现非常困难而且有意思?</span><br><span class="line">  * 不要忘记工作环境:古怪的硬件设备,功能弱小的调试工具</span><br><span class="line">  * 它必须得有效率(因此是底层?)</span><br><span class="line">...但是也需要一定抽象和可移植(因此是上层?)</span><br><span class="line">  * 功能强大</span><br><span class="line">...但是简单(因此有一些可组合的构建块?)</span><br><span class="line">  * 很有特点的交互方式: `fd = open(); ...; fork()`</span><br><span class="line">  * 行为交互方式: CPU优先级 vs 内存管理器</span><br><span class="line">  * 开放问题:安全,性能,开发新硬件</span><br></pre></td></tr></table></figure></li></ul></li><li><p>You’ll be glad you learned about operating systems if you…</p><ul><li>want to work on the above problems</li><li>care about what’s going on under the hood</li><li>have to build high-performance systems</li><li>need to diagnose bugs or security problems<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 学习操作系统你将会很开心,如果你...</span><br><span class="line">  * 想要从事于上述问题</span><br><span class="line">  * 关心在&quot;头巾&quot;下面到底发生了什么</span><br><span class="line">  * 必须构建高性能的系统</span><br><span class="line">  * 需要诊断错误(bugs)或安全问题</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>Class structure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">课程结构</span><br></pre></td></tr></table></figure></p><ul><li><p>See web site: <a href="https://pdos.csail.mit.edu/6.828" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体查看网站: https://pdos.csail.mit.edu/6.828</span><br></pre></td></tr></table></figure></li><li><p>Lectures</p><ul><li>O/S ideas</li><li>detailed inspection of xv6, a traditional O/S</li><li>xv6 programming homework to motivate lectures</li><li>papers on some recent topics<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 课程讲座</span><br><span class="line">  * 操作系统相关概念</span><br><span class="line">  * 针对xv6, 一种经典的操作系统进行详细查看和学习</span><br><span class="line">  * 用xv6编程作业引导和推动课程讲座</span><br><span class="line">  * 近年一些相关主题的论文</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Labs: JOS, a small O/S for x86 in an exokernel style</p><ul><li>you build it, 5 labs + final lab of your choice</li><li>kernel interface: expose hardware, but protect – few abstractions!</li><li>unprivileged user-level library: fork, exec, pipe, …</li><li>applications: file system, shell, ..</li><li>development environment: gcc, qemu</li><li>lab 1 is out<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 实验: JOS, 一个小的应用于x86架构的exokernel风格的操作系统</span><br><span class="line">  * 你来构建它,通过5个课内实验和一个你选择的最终实验完成</span><br><span class="line">  * 内核接口:暴露硬件,但是仍要保护起来--几乎没有抽象!</span><br><span class="line">  * 无特权的用户层次库:fork,exec,pipe,...</span><br><span class="line">  * 应用: 文件系统, shell, ..</span><br><span class="line">  * 开发环境: gcc, qemu</span><br><span class="line">  * lab 1 已经发放</span><br></pre></td></tr></table></figure></li></ul><p>(demo: build JOS and run ls)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(示例:构建JOS并且运行ls命令)</span><br></pre></td></tr></table></figure></li><li><p>Xv6 and JOS<br>Two different designs<br>Hopefully will force you understand issues better, but will be confusing too<br>Neither has the complexity of a real OS<br>(demo: build Linux)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Xv6和JOS</span><br><span class="line">  两种不同的设计</span><br><span class="line">  希望能够促使你更好地理解问题,但是也会带来困惑</span><br><span class="line">  也不会有一个真正的操作系统的复杂</span><br><span class="line">  (示例: 构建Linux)</span><br></pre></td></tr></table></figure></li><li><p>Two exams: midterm during class meeting, final in finals week</p></li></ul><p>Introduction to system calls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有关系统调用的介绍</span><br></pre></td></tr></table></figure></p><ul><li><p>6.828 is largely about design and implementation of system call<br>interface. let’s look at how programs use that interface.<br>we’ll focus on UNIX (Linux, Mac, POSIX, &amp;c).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 6.828很大一部分是关于设计和实现系统调用接口. 让我们来看看程序是如何使用该接口的.</span><br><span class="line">我们将关注类UNIX系统(Linux, Mac, POSIX, 等等).</span><br></pre></td></tr></table></figure></li><li><p>a simple example: what system calls does “ls” call?</p><ul><li>Trace system calls:<ul><li>On OSX: sudo dtruss /bin/ls</li><li>On Linux: strace /bin/ls</li></ul></li><li>so many system calls!<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 一个简单的例子: &quot;ls&quot;调用了哪些系统调用?</span><br><span class="line">  * 追踪调用的系统调用</span><br><span class="line">    * 在OSX: sudo dtruss /bin/ls</span><br><span class="line">    * 在Linux: strace /bin/ls</span><br><span class="line">  * 太多太多系统调用了!</span><br></pre></td></tr></table></figure></li></ul></li><li><p>example: copy input to output<br>cat copy.c<br>cc -o copy copy.c<br>./copy<br>read a line, then write a line<br>note: written in C, the traditional O/S language</p><ul><li><p>first read/write argument is a “file descriptor” (fd)<br>passed to kernel to tell it what “open file” to read/write<br>must previously have been opened, connects to file/device/socket/&amp;c<br>UNIX convention: fd 0 is “standard input”, 1 is “standard output”  </p></li><li><p>sudo dtruss ./copy<br>read(0x0, “123\n\0”, 0x80)         = 4 0<br>write(0x1, “123\n@\213\002\0”, 0x4)         = 4 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 示例:将输入拷贝至输出</span><br><span class="line">  cat copy.c</span><br><span class="line">  cc -o copy copy.c</span><br><span class="line">  ./copy</span><br><span class="line">  读一行,然后写一行</span><br><span class="line">  注意:用编写传统操作系统的语言--C语言来编写</span><br><span class="line"></span><br><span class="line">  * 第一个 读/写 参数是一个&quot;文件描述元&quot;(fd)</span><br><span class="line">    传递给内核来告诉它是什么&quot;已打开的文件&quot;需要读/写操作</span><br><span class="line">    文件必须要提前已经被打开, 连接到file/device/socket/等等</span><br><span class="line">    UNIX约定: fd 0 是&quot;标准输入&quot;, 1 is &quot;标准输出&quot;</span><br><span class="line"></span><br><span class="line">  * sudo dtruss ./copy</span><br><span class="line">    read(0x0, &quot;123\n\0&quot;, 0x80) = 4 0</span><br><span class="line">    write(0x1, &quot;123\n@\213\002\0&quot;, 0x4) = 4 0</span><br></pre></td></tr></table></figure></li></ul></li><li><p>example: creating a file<br>cat open.c<br>cc -o open open.c<br>./open<br>cat output.txt<br>note: creat() turned into open()<br>note: can see actual FD with dtruss<br>note: this code ignores errors – don’t be this sloppy!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 示例: 新建一个文件</span><br><span class="line">  cat open.c</span><br><span class="line">  cc -o open open.c</span><br><span class="line">  ./open</span><br><span class="line">  cat output.txt</span><br><span class="line">  注意: creat()变为了open()</span><br><span class="line">  注意: 可以通过dtruss查看到真实的FD</span><br><span class="line">  注意: 这段代码忽略了错误--可不能这么粗心!</span><br></pre></td></tr></table></figure></li><li><p>example: redirecting standard output<br>cat redirect.c<br>cc -o redirect redirect.c<br>./redirect<br>cat output.txt<br>man dup2<br>sudo dtruss ./redirect<br>note: writes output.txt via fd 1<br>note: stderr (standard error) is fd 2 – that’s why creat() yields FD 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 示例:重定向标准输出</span><br><span class="line">  cat redirect.c</span><br><span class="line">  cc -o redirect redirect.c</span><br><span class="line">  ./redirect</span><br><span class="line">  cat output.txt</span><br><span class="line">  man dup2</span><br><span class="line">  sudo dtruss ./redirect</span><br><span class="line">  注意: 通过fd 1写入output.txt</span><br><span class="line">  注意: stderr (标准错误) 是 fd 2 -- 这就是为什么 creat() 产生了 FD 3</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>a more interesting program: the Unix shell.</p><ul><li>it’s the Unix command-line user interface</li><li>it’s a good illustration of the UNIX system call API</li><li>some example commands:<br>ls<br>ls &gt; junk<br>ls | wc -l<br>ls | wc -l &gt; junk  </li><li>the shell is also a programming/scripting language<br>cat &gt; script<br>  &emsp;echo one<br>  &emsp;echo two<br>sh &lt; script</li><li>the shell uses system calls to set up redirection, pipes, waiting<br>programs like wc are ignorant of input/output setup<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 一个更有意思的程序: the Unix shell.</span><br><span class="line">  * 它是Unix系统的命令行用户接口</span><br><span class="line">  * 对于UNIX系统调用API,它是一个很好的举例</span><br><span class="line">  * 一些示例命令:</span><br><span class="line">    ls</span><br><span class="line">    ls &gt; junk</span><br><span class="line">    ls | wc -l</span><br><span class="line">    ls | wc -l &gt; junk</span><br><span class="line">  * shell还是一种程序/脚本语言</span><br><span class="line">    cat &gt; script</span><br><span class="line">      echo one</span><br><span class="line">      echo two</span><br><span class="line">    sh &lt; script</span><br><span class="line">  * shell使用系统调用来启动重定向, 管道, 等待</span><br><span class="line">    程序如wc对于输入/输出的启动是不知晓的</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Let’s look at source for a simple shell, sh.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让我们来看看一个简易的shell源代码文件,sh.c</span><br></pre></td></tr></table></figure><ul><li><p>main()<br>basic organization: parse into tree, then run<br>main process: getcmd, fork, wait<br>child process: parsecmd, runcmd<br>why the fork()?<br>  &emsp;we need a new process for the command<br>what does fork() do?<br>  &emsp;copies user memory<br>  &emsp;copies kernel state e.g. file descriptors<br>  &emsp;so “child” is almost identical to “parent”<br>  &emsp;child has different “process ID”<br>  &emsp;both processes now run, in parallel<br>  &emsp;fork returns twice, once in parent, once in child<br>  &emsp;fork returns child PID to parent<br>  &emsp;fork returns 0 to child<br>  &emsp;so sh calls runcmd() in the child process<br>why the wait()?<br>what if child exits before parent calls wait()?  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* main()</span><br><span class="line">  basic organization: parse into tree, then run</span><br><span class="line">  main process: getcmd, fork, wait</span><br><span class="line">  child process: parsecmd, runcmd </span><br><span class="line">  why the fork()?</span><br><span class="line">    we need a new process for the command</span><br><span class="line">  what does fork() do?</span><br><span class="line">    copies user memory</span><br><span class="line">    copies kernel state e.g. file descriptors</span><br><span class="line">    so &quot;child&quot; is almost identical to &quot;parent&quot;</span><br><span class="line">    child has different &quot;process ID&quot;</span><br><span class="line">    both processes now run, in parallel</span><br><span class="line">    fork returns twice, once in parent, once in child</span><br><span class="line">    fork returns child PID to parent</span><br><span class="line">    fork returns 0 to child</span><br><span class="line">    so sh calls runcmd() in the child process</span><br><span class="line">  why the wait()?</span><br><span class="line">  what if child exits before parent calls wait()?</span><br></pre></td></tr></table></figure></li><li><p>runcmd()<br>executes parse tree generated by parsecmd()<br>distinct cmd types for simple command, redirection,<br>pipe</p></li><li><p>runcmd() for simple command with arguments<br>execvp(cmd, args)<br>man execvp<br>ls command &amp;c exist as executable files, e.g. /bin/ls<br>execvp loads executable file over memory of current process<br>jumps to start of executable – main()<br>note: execvp doesn’t return if all goes well<br>note: execvp() only returns if it can’t find the executable file<br>note: it’s the shell child that’s replaced with execvp()<br>note: the main shell process is still wait()ing for the child  </p></li><li><p>how does runcmd() handle I/O redirection?<br>e.g. echo hello &gt; junk<br>parsecmd() produces tree with two nodes<br>  &emsp;cmd-&gt;type=’&gt;’, cmd-&gt;file=”junk”, cmd-&gt;cmd=…<br>  &emsp;cmd-&gt;type=’ ‘, cmd-&gt;argv=[“echo”, “hello”]<br>the open(); dup2() causes FD 1 to be replaced with FD to output file<br>it’s the shell child process that changes its FD 1<br>execvp preserves the FD setup<br>so echo runs with FD 1 connected to file junk<br>again, very nice that echo is oblivious, just writes FD 1  </p></li><li><p>why are fork and exec separate?<br>perhaps wasteful that fork copies shell memory, only<br>  to have it thrown away by exec<br>the point: the child gets a chance to change FD setup<br>  before calling exec<br>and the parent’s FD set is not disturbed<br>you’ll implement tricks to avoid fork() copy cost in the labs</p></li><li><p>how does the shell implement pipelines?<br>$ ls | wc -l</p></li><li><p>the kernel provides a pipe abstraction<br>int fds[2]<br>pipe(fds)<br>a pair of file descriptors: a write FD, and a read FD<br>data written to the write FD appears on the read FD  </p></li><li><p>example: pipe1.c<br>read() blocks until data is available<br>write() blocks if pipe buffer is full</p></li><li><p>pipe file descriptors are inherited across fork<br>so pipes can be used to communicate between processes<br>example: pipe2.c<br>for many programs, just like file I/O, so pipes work for stdin/stdout</p></li><li><p>for ls | wc -l, shell must:</p><ul><li>create a pipe</li><li>fork</li><li>set up fd 1 to be the pipe write FD</li><li>exec ls</li><li>set up wc’s fd 0 to be pipe read FD</li><li>exec wc</li><li>wait for wc<br>[diagram: sh parent, sh child, ls grandchild, wc grandchild, stdin/out for each]<br>case ‘|’ in sh.c<br>note: sh close()es unused FDs  <pre><code>&amp;emsp;so exit of writer produces EOF at reader</code></pre></li></ul></li><li><p>you’ll implement pieces of a shell in an upcoming homework</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;6.828 2018 Lecture 1: O/S overview&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Assignment for Stanford CS143:Compilers</title>
    <link href="http://andj.me/2019/01/20/Assignment-for-Stanford-cs143-Compilers/"/>
    <id>http://andj.me/2019/01/20/Assignment-for-Stanford-cs143-Compilers/</id>
    <published>2019-01-20T10:50:38.000Z</published>
    <updated>2019-09-07T05:20:46.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大三上半年这个学期,学校开设了编译原理这门课程,使用的是 <em>Stanford</em>  <a href="http://web.stanford.edu/class/cs143/" target="_blank" rel="noopener">CS143</a>这门课的课件来教授.尽管如此,因为课时的原因,很多关于这门课的精华部分点到为止,而且这门课最具特色的实习我们也没有完成.这个假期,我想找空闲时间,完成这门课程的5次实习,把自己学习到的编译原理的知识应用一下.</p><h3 id="Introduction-to-Stanford-CS143"><a href="#Introduction-to-Stanford-CS143" class="headerlink" title="Introduction to Stanford CS143"></a>Introduction to Stanford CS143</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这门课程在 <em>Coursera</em> 上也有公开课程,不过我这里还是使用了 <em>Stanford</em> 课程官网上的课件来学习.这门课程的历史很久, <em>Assignment</em> 也在不断变化,之前的课程(2012年之前)要求实现的是一种名叫’ <em>Decaf</em> ‘的语言,可以找到相应的学习资料在该<a href="https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/" target="_blank" rel="noopener">历史网址</a>,后面课程更新后,实现的是一种名叫 <em>Cool</em> 的语言.关于这门语言的介绍在<a href="https://en.wikipedia.org/wiki/Cool_(programming_language" target="_blank" rel="noopener">Wikipedia</a>)和<a href="http://theory.stanford.edu/~aiken/software/cool/cool.html" target="_blank" rel="noopener">语言官网</a>上可以找到. </p><h3 id="Cool-Language"><a href="#Cool-Language" class="headerlink" title="Cool Language"></a>Cool Language</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>Wikipedia</em> 上针对 <em>Cool</em> 语言的解释为: <em>an acronym for Classroom Object Oriented Language, is a computer programming language designed by Alexander Aiken for use in an undergraduate compiler course project.</em>  即是一种用于教学使用的面向对象语言.对于该门语言官网上解释来说,  <em>Cool is a small language designed for use in an undergraduate compiler course project. While small enough for a one term project, Cool still has many of the features of modern programming languages(有很多现代编程语言的特点), including objects(对象), automatic memory management(动态内存管理), and strong static typing(强静态类型). Cool is built entirely on public domain tools; it generates code for a MIPS simulator, spim (产生MIPS汇编代码). Thus, the project should port easily to other platforms(跨平台). The project has been used for teaching compilers at many institutions and the software is stable.</em> </p><h3 id="About-Assignment"><a href="#About-Assignment" class="headerlink" title="About Assignment"></a>About Assignment</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上给出了 <em>Cool</em> 语言的各种介绍链接,包含针对于 <em>assignment</em> 需要使用的工具文档,如 <em>Flex,Bison</em> .该课程包含5次 <em>program assignment</em> ,分块实现 <em>Cool</em> 语言. <em>Stanford</em> 针对上机教学环境有自己搭建的教学资源服务器,很多需要的软件运行环境我们是访问不到的,需要自己手动配置.不过,针对于这门课放出了<a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/6b750292e90d4950b895f621a5671b49/" target="_blank" rel="noopener">软件运行环境</a>供我们下载使用.该资源为 <em>virtual box</em> 虚拟机,环境系统为Linux,关于课程所需要的环境已经部署好,我们可以将文件copy至virtual box打开,使用虚拟机完成实习.对我来说的话,本身有现成的Linux环境,虚拟机太慢了,我直接从虚拟机中将文件copy出来放在自己的Linux系统中(给出的Linux虚拟环境太老了,很多https网站内置浏览器不能访问,实在是满足不了需求).当然,环境迁移的教程官网上都有详细说明.</p><h3 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前环境已经搭建完毕,紧接着按5次 <em>assignment</em> 来实现.后面的文章分块儿讲述自己的实现过程,也是在不断地督促自己高效率完成.新的学习任务,给自己一点动力,用 <em>Cool</em> 语言写一句祝福为自己加油打气:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/01/20/Assignment-for-Stanford-cs143-Compilers/code.png" alt="code" title="">                </div>                <div class="image-caption">code</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/01/20/Assignment-for-Stanford-cs143-Compilers/result.png" alt="result" title="">                </div>                <div class="image-caption">result</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大三
      
    
    </summary>
    
    
      <category term="cs143" scheme="http://andj.me/tags/cs143/"/>
    
      <category term="compiler" scheme="http://andj.me/tags/compiler/"/>
    
      <category term="cool" scheme="http://andj.me/tags/cool/"/>
    
      <category term="assignment" scheme="http://andj.me/tags/assignment/"/>
    
  </entry>
  
  <entry>
    <title>搭建多端编写hexo博客环境</title>
    <link href="http://andj.me/2018/12/25/%E6%90%AD%E5%BB%BA%E5%A4%9A%E7%AB%AF%E7%BC%96%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83/"/>
    <id>http://andj.me/2018/12/25/搭建多端编写hexo博客环境/</id>
    <published>2018-12-24T19:44:29.000Z</published>
    <updated>2019-09-07T05:20:46.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>这是一篇指导搭建多端编写Hexo博客环境的文章。所谓多端搭建，是指本地已经搭建好了Hexo博客，并且能够部署至服务器，但是如果换一台PC，则没有该博客部署需要的源代码文件，博客就必须重建。因此需要让博客编写环境多端搭建，使便于博客编写环境迁移，避免出现因重置系统、文件丢失等因素造成博客无法继续的问题。</p><h2 id="Start-With"><a href="#Start-With" class="headerlink" title="Start With"></a>Start With</h2><ol><li>Windows 10系统下搭建完成hexo环境</li><li>基本软件安装完成: git, node.js</li><li>博客已部署至 github</li><li>计划迁移环境：Linux，测试系统为 deepin 15.8<h2 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h2><h4 id="一、Github保存代码文件"><a href="#一、Github保存代码文件" class="headerlink" title="一、Github保存代码文件"></a>一、Github保存代码文件</h4>为了让环境迁移，首先必须保存代码文件，将博客所有文件放在Github远程仓库里面，基于这些文件我们可以在其他平台上重建博客编写环境。<br>注意hexo搭建的博客文件夹下有.gitignore，该文件即github上传时需要忽略的文件，默认如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></li></ol><p>这些文件也都是重建博客不需要的文件，剩下的都是必须文件，这里给出我上传备份的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scaffolds/*</span><br><span class="line">source/*</span><br><span class="line">themes/*</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure></p><p>这里不再赘述文件夹上传，保存即可，该代码库记为 Blog。</p><h4 id="二、迁移环境搭建"><a href="#二、迁移环境搭建" class="headerlink" title="二、迁移环境搭建"></a>二、迁移环境搭建</h4><p>目标迁移环境系统为deepin 15.8</p><ol><li><p>安装node.js环境</p><p> 选择合适的安装位置，这里安装位置为 ~/Softwares</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Softwares$ wget https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p> 解压该文件并更名node.js：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Softwares$ tar -zxvf node-v8.9.4-linux-x64.tar.xz</span><br><span class="line">andj@deepin:~/Softwares$ mv node-v8.9.4-linux-x64 node.js</span><br></pre></td></tr></table></figure><p> 将node.js/bin环境配置入环境变量：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Softwares$ sudo vim /etc/profile</span><br><span class="line">                        文件中添加: </span><br><span class="line">                            PATH=/home/andj/Softwares/node.js/bin:$PATH</span><br><span class="line">andj@deepin:~/Softwares$ source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>配置hexo</p><p> 下载之前上传的hexo源代码文件到合适位置：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Project$ git clone git@github.com:XXX/Blog.git</span><br></pre></td></tr></table></figure><p> 切入博客文件下安装hexo</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Project$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p> 初始化环境</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Project$ npm install</span><br></pre></td></tr></table></figure><p> 这里注意不需要hexo init，因为主要文件已经存在，不需要完全重置。</p></li><li><p>测试搭建的环境</p><p> 创建新博文</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Project$ hexo create &quot;test&quot;</span><br></pre></td></tr></table></figure><p> 针对该博文做出修改</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Project/Blog$ cd source/_post</span><br><span class="line">andj@deepin:~/Project/Blog/source/_post/$ vim test</span><br></pre></td></tr></table></figure><p> 退回原根目录进行部署</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">andj@deepin:~/Project/Blog/source/_post/$ cd ../..</span><br><span class="line">andj@deepin:~/Project/Blog/$ hexo g</span><br><span class="line">andj@deepin:~/Project/Blog/$ hexo d</span><br></pre></td></tr></table></figure></li><li><p>查看网页是否搭建成功</p></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">使用hexo，如果换了电脑怎么更新博客？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;这是一篇指导搭建多端编写Hexo博客环境的文章。所谓多端搭建，是指本地已经搭建好了Hexo博客，并且
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://andj.me/tags/hexo/"/>
    
      <category term="environment" scheme="http://andj.me/tags/environment/"/>
    
      <category term="blog" scheme="http://andj.me/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>LuoGu_1056_1328_1563</title>
    <link href="http://andj.me/2018/09/03/LuoGu-1056-1328-1563/"/>
    <id>http://andj.me/2018/09/03/LuoGu-1056-1328-1563/</id>
    <published>2018-09-02T17:37:29.000Z</published>
    <updated>2019-09-07T05:20:46.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P1056-排座位"><a href="#P1056-排座位" class="headerlink" title="P1056 排座位"></a>P1056 排座位</h2><p><a href="https://www.luogu.org/problemnew/show/P1056" target="_blank" rel="noopener">题目入口</a></p><p>这道题的算法标签是 <code>贪心</code> 和 <code>排序</code> 。这道题的背景很有意思，给出了班级的整体布局，给出了班级内上课交流的同学的相邻坐标，同时也给出了针对班级行和列需要规划的过道数。从理想状况来看，当然是把每一个同学和其他所有同学完全隔离开，即可避免任何两个同学之前上课交流，但是偏偏题目中有限制，隔离的行列必须是题目测试数据给出的指定值，不能随意设置隔道进行隔离。</p><p>那么这道题的思路就变成一个求解最优解问题，即选择有限个隔道的分布位置，尽可能多地分开交流的同学对数。这里用到了贪心的思想，贪心策略是：每次选择所有相邻的两行（列）中 <code>交头接耳的同学对</code> 最多的那一行（列）设置通道隔开。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P1056 排座位</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//row and column 行和列</span></span><br><span class="line"><span class="keyword">int</span> row[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> column[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> r[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> c[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k,l,d;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;k&gt;&gt;l&gt;&gt;d;</span><br><span class="line">    <span class="keyword">int</span> x,y,p,q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;p&gt;&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(x==p)</span><br><span class="line">            column[y&lt;q?y:q]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row[x&lt;p?x:p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row[j]&gt;maxx)&#123;</span><br><span class="line">                maxx=row[j];</span><br><span class="line">                pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r[pos]++;</span><br><span class="line">        row[pos]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(column[j]&gt;maxx)&#123;</span><br><span class="line">                maxx=column[j];</span><br><span class="line">                pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c[pos]++;</span><br><span class="line">        column[pos]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1001</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r[i]!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1001</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P1328 生活大爆炸版石头剪刀布</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> judge[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    judge[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;judge[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">-1</span>;judge[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">1</span>;judge[<span class="number">0</span>][<span class="number">3</span>]=<span class="number">1</span>;judge[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">-1</span>;</span><br><span class="line">    judge[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;judge[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">-1</span>;judge[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">1</span>;judge[<span class="number">1</span>][<span class="number">4</span>]=<span class="number">-1</span>;</span><br><span class="line">    judge[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;judge[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">-1</span>;judge[<span class="number">2</span>][<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">    judge[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">0</span>;judge[<span class="number">3</span>][<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">    judge[<span class="number">4</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,na,nb;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;na&gt;&gt;nb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;na;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nb;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ca=<span class="number">0</span>,cb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pa=<span class="number">0</span>,pb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa==na) pa=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pb==nb) pb=<span class="number">0</span>;</span><br><span class="line">        r=a[pa]&lt;=b[pb]?judge[a[pa]][b[pb]]:-judge[b[pb]][a[pa]];</span><br><span class="line">        <span class="keyword">if</span>(r==<span class="number">1</span>)&#123;</span><br><span class="line">            ca++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="number">-1</span>)&#123;</span><br><span class="line">            cb++;</span><br><span class="line">        &#125;</span><br><span class="line">        pa++;</span><br><span class="line">        pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ca&lt;&lt;<span class="string">" "</span>&lt;&lt;cb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P1563 玩具谜题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> people[<span class="number">100000</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> direction[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;direction[i];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,people[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a,s;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>((a==<span class="number">0</span> &amp;&amp; direction[p]==<span class="number">1</span>)||(a==<span class="number">1</span> &amp;&amp; direction[p]==<span class="number">0</span>))&#123;</span><br><span class="line">            p+=s;</span><br><span class="line">            p%=n;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((a==<span class="number">0</span> &amp;&amp; direction[p]==<span class="number">0</span>)||(a==<span class="number">1</span> &amp;&amp; direction[p]==<span class="number">1</span>))&#123;</span><br><span class="line">            p-=s;</span><br><span class="line">            p+=n;</span><br><span class="line">            p%=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;people[p];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P1056-排座位&quot;&gt;&lt;a href=&quot;#P1056-排座位&quot; class=&quot;headerlink&quot; title=&quot;P1056 排座位&quot;&gt;&lt;/a&gt;P1056 排座位&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/
      
    
    </summary>
    
      <category term="Online Judge题解" scheme="http://andj.me/categories/Online-Judge%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="洛谷1056" scheme="http://andj.me/tags/%E6%B4%9B%E8%B0%B71056/"/>
    
      <category term="洛谷1328" scheme="http://andj.me/tags/%E6%B4%9B%E8%B0%B71328/"/>
    
      <category term="洛谷1563" scheme="http://andj.me/tags/%E6%B4%9B%E8%B0%B71563/"/>
    
  </entry>
  
  <entry>
    <title>督促自己学习《算法艺术与信息学竞赛》</title>
    <link href="http://andj.me/2018/07/30/%E7%9D%A3%E4%BF%83%E8%87%AA%E5%B7%B1%E5%AD%A6%E4%B9%A0%E3%80%8A%E7%AE%97%E6%B3%95%E8%89%BA%E6%9C%AF%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B%E3%80%8B/"/>
    <id>http://andj.me/2018/07/30/督促自己学习《算法艺术与信息学竞赛》/</id>
    <published>2018-07-29T22:25:31.000Z</published>
    <updated>2019-09-07T05:20:46.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="督促自己学习《算法艺术与信息学竞赛》"><a href="#督促自己学习《算法艺术与信息学竞赛》" class="headerlink" title="督促自己学习《算法艺术与信息学竞赛》"></a>督促自己学习《算法艺术与信息学竞赛》</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机科学(CS)这个专业，算法能力是尤为看重的，尤其是现在，人工智能、区块链、机器学习等热门话题不仅活跃在我们CS圈内，还成为了全社会的关注焦点。不管这些新兴技术今后发展如何，单纯就技术而言，它是无罪的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，学生时代，我们仍可以有环境 “两耳不闻窗外事，一心只读圣贤书”。我创建这个属于自己的博客，即是记录自己平时的点点滴滴，也是想借这个机会，能让我有所产出。上大学这两年，我给自己平添的许多的烦恼，给自己强行贴上了很多的标签，希望自己能尽快在自己的专业上获得进步，少了之前潜下心来做学问的忍耐。手机中各种新闻渠道每天对我狂轰滥炸，光是新闻，微博，微信公众号足以让我花费数个小时阅读积攒下来的文章。之前总是在安慰自己，多点开花才能结果，不要把鸡蛋放在同一个篮子里，现在想来是心思越来越难以集中思考，大部分时间都只是在 “接受”， 从未有有价值的产出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题症结所在已经找到，我便把手机中这些软件统统删去，给自己保留了尽可能少而有价值的一两个软件作为自己的新闻和知识来源。那么腾出的时间，我便能够专心做自己感兴趣的事情，做自己的学问。这也就是为什么我开启了自己的读书计划——《算法艺术与信息学竞赛》。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我高中并没有搞OI竞赛，现在也没有系统地学习ACM，站在这本书面前，我只作为一名单纯的算法竞赛爱好者去学习，有机会的话，我也希望自己能够在ACM历练一下。尤其是现在各大OJ平台非常完善，能够在自己的学习之余不断练习，单是因为兴趣，总能找到志同道合的伙伴给出漂亮的Solution。算法竞赛练习既是自己的课余兴趣，也能够通过这个锻炼自己，在今后的学习和研究中打开思路。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《算法艺术与信息学竞赛》这本书是刘汝佳的经典之作，OI圈的人成为传说中的 “黑书”。我第一次见到这本书，是在高中时一个搞OI的舍友拿着它激动万分地和我说有人赠送给他这本传说中的黑书，当然这位舍友也是神人，最终进入国家集训队，保送清华大学。机缘巧合，我在校图书馆见到了这本书，馆藏只有两本。这本书定位并不是针对新人，而是给竞赛选手提升经验的。内容上看，这本书代码和伪代码都不多，大体上是从思路上进行展开，基本上是纯思路的讲解，因此一定的领悟之上配合更多的练习是必要的。这本书再版后面对新人更加的友好，但是深度也打了一定的折扣，能拿到的这本书已经是绝版了，官方网站已经停止维护，随书在官网上附赠的资料也已经很难找到。不过也正是因为这本书有难度，自己才有了啃的兴趣。万幸的是，在CSDN上有圈内人提供了这本书的PDF版以及随书的很多资料，在本文末贴了出来。如果失效，请给我留言，以便我及时做出更新。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跟随我这本书学习的，当然少不了圣经 CLRS。CLRS的学习我注重于笔记，也会分享自己的学习文章，方便今后出现合适的机会重新学习。这篇文章，权当是给自己一个鼓励，一个督促。“万事开头难”，希望自己能够坚持下去，用心做自己感兴趣的事情。</p><p><a href="https://download.csdn.net/download/qwsqwa/6901769" target="_blank" rel="noopener">下载地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;督促自己学习《算法艺术与信息学竞赛》&quot;&gt;&lt;a href=&quot;#督促自己学习《算法艺术与信息学竞赛》&quot; class=&quot;headerlink&quot; title=&quot;督促自己学习《算法艺术与信息学竞赛》&quot;&gt;&lt;/a&gt;督促自己学习《算法艺术与信息学竞赛》&lt;/h1&gt;&lt;p&gt;&amp;nbsp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自我介绍一下</title>
    <link href="http://andj.me/2018/06/23/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B/"/>
    <id>http://andj.me/2018/06/23/自我介绍一下/</id>
    <published>2018-06-22T17:23:35.000Z</published>
    <updated>2019-09-07T05:20:46.745Z</updated>
    
    <content type="html"><![CDATA[<p>main<br>public<br>test deepin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;main&lt;br&gt;public&lt;br&gt;test deepin&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
