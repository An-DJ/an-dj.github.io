[{"title":"布尔代数与 bis, bic","date":"2020-01-30T21:27:26.000Z","path":"2020/01/31/布尔代数与bis-bic/","text":"Problem最近阅读 CSAPP 的时候，在第 2 章讲到布尔代数时引入了一个非常有意思的问题，题号为 2.13，题面如下： 20世纪70年代末至80年代末，Digital Equipment 的 VAX 计算机是一种很流行的机型。它没有布尔运算 AND 和 OR 指令，只有 bis（位设置）和 bic（位清除）这两种指令。两种指令的输入都是一个数据字 x 和一个掩码字 m。他们生成一个结果z，z是有根据掩码m的位来修改 x 的位得到的。使用 bis 指令，可以在 m 为 1 的每个位置上，将 z 对应的位置设为 1。使用 bic 指令，可以在 m 为 1 的每个位置上，将 z 对应的位置设为 0。为了弄清 bis 和 bic 运算与 C 语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 | 和 ^ 运算，即或运算和异或运算。示例如下：123456789101112131415161718/* Declarations of functions implementing operations bis and bic */int bis(intx, int m);int bic(int x, int m);/* Compute x|y using only calls to functions bis and bic */int bool_or(int x, int y)&#123; int result = _______; return result;&#125;/* Compute x^y using only calls to functions bis and bic */int bool_xor(int x, int y)&#123; int result = _______; return result;&#125; 其实，更一般意义上，我们可以考虑使用 bis 和 bic 实现所有的位运算符，即 &amp;、|、~ 和 ^。 bis 和 bic我们按照布尔代数的方式分别研究 bis 和 bic。 对于 bis (x, y)，有 bis (0, 0) = 0, bis (0, 1) = 1, bis (1, 0) = 1, bis (1, 1) = 1, 如下： - 0 1 0 0 1 1 1 1 对于 bic (x, y)，有 bic (0, 0) = 0, bic (0, 1) = 0, bic (1, 0) = 1, bic (1, 1) = 0, 如下： - 0 1 0 0 1 1 0 0 OR由真值表直接可以看出，bis 其实等价于 OR，因此 bool_or = bis (x, y)。 NOT取反操作就是 0 -&gt; 1，1 -&gt; 0，等价于将全是 1 进行 bic 操作，即 bool_not = bic (0xFFFFFFFF, x)，x 为 0 的位不会影响 0xFFFFFFFF 同位置的 1，x 为 1 的位会抹为 0，起到取反的效果。 AND由布尔运算得关系式：x &amp; y = ~ ( ~ x | ~ y)，利用上面所得可推出 bool_and = bic (0xFFFFFFFF, bis (bic (0xFFFFFFFF, x), bic (0xFFFFFFFF, y)))。 XORXOR 是最难搞定的一个。注意观察有：1234bis (bic (0,1)，bic (1,0)) = bis (0,1) = 1bis (bic (1,0), bic (0,1)) = bis (1,0) = 1bis (bic (0,0), bic (0,0)) = bis (0,0) = 0bis (bic (1,1), bic (1,1)) = bis (0,0) = 0 可得出 bool_xor = bis (bic (x, y), bic (y, x))。 The End附上代码实现。12345678910111213141516171819202122232425262728293031/* Declarations of functions implementing operations bis and bic */int bis(intx, int m);int bic(int x, int m);/* Compute x|y using only calls to functions bis and bic */int bool_or(int x, int y)&#123; int result = bis (x, y); return result;&#125;/* Compute x^y using only calls to functions bis and bic */int bool_xor(int x, int y)&#123; int result = bis (bic (x, y), bic (y, x)); return result;&#125;/* Compute x&amp;y using only calls to functions bis and bic */int bool_and(int x, int y)&#123; int result = bic (0xFFFFFFFF, bis (bic (0xFFFFFFFF, x), bic (0xFFFFFFFF, y))); return result;&#125;/* Compute ~x using only calls to functions bis and bic */int bool_not(int x)&#123; int result = bic (0xFFFFFFFF, x); return result;&#125;","tags":[{"name":"布尔代数","slug":"布尔代数","permalink":"http://andj.me/tags/布尔代数/"},{"name":"csapp","slug":"csapp","permalink":"http://andj.me/tags/csapp/"}]},{"title":"leveldb:Arena","date":"2019-12-22T15:30:20.000Z","path":"2019/12/22/leveldb-Arena/","text":"Test1234567891011121314151617digraph st2&#123;fontname = &quot;Verdana&quot;;fontsize = 10;rankdir=TB; node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;]; edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;]; st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;];st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;];st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;];st_table:bins -&gt; st_table_entry:head;st_table:type -&gt; st_hash_type:head;st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];&#125;","tags":[]},{"title":"Raft浅谈","date":"2019-09-07T13:39:17.000Z","path":"2019/09/07/Raft浅谈/","text":"分布式一致性(Distributed Consensus)What 分布式环境：复杂，Some of the processes (agents) may fail or be unreliable in other ways 一致性：requires agreement among a number of processes (or agents) for a single data value 单个节点（数据副本）更新，所有节点数据也要相应更新。 DescriptionTermination Eventually, every correct process decides some value. Integrity ( be honest ) If all the correct processes proposed the same value v, then any correct process must decide v. Agreement Every correct process must agree on the same value. Where Leader election / Mutual Exclusion Commit or Abort in distributed transactions Reaching agreement about which process has failed Clock phase synchronization 一致性协议(Consensus Protocol) 2PC (Two-Phase Commit) 3PC (Three-Phase Commit) Paxos and its variants Chubby ZAB (ZooKeeper Atomic Broadcast) Raft … Paxos Lamport 提出的一种基于消息传递的分布式一致性算法 The Part-Time Parliament, 1998，首篇论文，以故事性叙述（同行表示看不懂） Paxos Made Simple, 2001，再篇，算法描述（表示仍然看不懂） too difficult to understand and implement 产生了许多结合实际的衍生实现 Raft 论文: In Search of an Understandable Consensus Algorithm (Extended Version) 基于日志复制 ( replicated log ) 简单，易懂，易于实现，这是 Raft 的研究目的 Stanford 调查发现，对于学生，Raft 算法比 Paxos 更加易于学习 3 part: leader election, log replication, and safety 复制状态机 Replicated state machines 复制状态机 一致性算法管理来自客户端指令的复制日志 状态机从日志中处理相同顺序的相同指令，所以产生的结果一致 保证复制日志相同 –&gt; 保证一致性 Raft 基础 Raft 集群中包含若干节点，通常是5个 半数以上的节点存活，保持可用性 节点角色状态机（3种角色） role 状态机 通常情况下，系统中只有一个 leader ，其他都是 follower 如果客户端与其中一个 follower，其会请求重定向 领导人任期 每一段任期都是从一次选举开始，任期内 leader 唯一且发挥作用 任期是一种逻辑时钟，任期号单调增 某个 leader 发现有节点任期号比自己大？ 切换为 follower 某个请求不属于该任期处理？拒绝 领导选举 leader election集群初始化 or 当现存的领导人宕机的时候，一个新的领导人需要被选举出来。 心跳机制：候选人拉票，半数以上赞同即成为下一任 leader 选举 RPC，会带有部分信息，如任期号 选举结果：自己是 leader；别的节点是 leader；超时没选出来 选举先来先服务 RPC心跳包 任期号比自己的小？不选它 没选出来怎么办？选举超时，可以再选一次 一直超时一直选怎么办？随机指定超时时间 总是能选出有且只有一个 leader 日志复制 log replication一旦一个 leader 被选出来，它便可以对客户端进行服务。leader 必须从客户端接收日志然后复制到集群中的其他节点，且强制要求其他节点的日志保持和自己相同。 流程：客户端发起指令日志 –&gt; leader 存储日志并发送复制RPC给其他节点（通信存在问题，会不断进行尝试） –&gt; 被安全复制后，leader 将其执行到自身的状态机，返回结果给客户端 –&gt; 其他节点执行 日志有序号，有创建时的任期号，有操作指令 日志复制RPC， 大多数节点日志复制成功，leader 则提交，通过心跳告知其他节点执行到状态机 leader 保存跟踪最大可以提交的日志 index 日志匹配特性 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同 leader 崩溃带来的问题follower 可能有当前 leader 有的条目，也可能缺少当前 leader 部分条目，也可能兼有。如下一种情况： 可能产生这样的原因是：f 当选为 leader，写入日志后没有成功复制就崩溃了；很快 f 机器又重启了，又再次被选为 leader，写入日志后又再次崩溃了，之后是 e，等等。最终会造成上图的结果。leader 是第一行的机器，任期为8。解决办法强制 follower 直接复制 leader 的日志。 leader 从日志最后一条开始往前找，一个对应其他follower的 nextIndex[] 数组维护，初始为leader尾index+1； 每次尝试写入 follower ，不一致则 nextIndex-1，直到找到一致的地方； 强制复制 leader nextIndex 到末尾的部分给 follower 保证了日志匹配特性！ 安全性 safety前述算法实际上并不能够充分保证每一个状态机会按照相同的顺序执行相同的指令，会存在一些问题，比如 leader 提交日志， 但某个 follower 变为不可用，之后该 follower 被选举为 leader，并且覆盖了这些日志条目。因此，可能存在不同的状态机执行不同的指令序列。 如下有两处规则限制： 1. 选举限制 leader 必须包含所有的已 commit 的日志 选 leader 时，必须遵循如上规则，方法是，投票人会投给与大多数节点一样“新”的节点；拒绝非新节点 新？比较条件是，两份日志最后条目任期号大的较“新”，任期号一致则日志较长的“新” 这里论文里没有给出更细致的说明，需要考虑的问题是，为什么这样的策略选出来的leader一定是包含所有已提交的日志的？ 实际上确实是这样的 2. 提交之前任期内的日志 考虑如上问题。S1作为 leader，任期为2，复制到S2后崩溃；再次选举，S5获选为leader，任期为3，写入自身日志后崩溃；再次选举，S1的末尾日志是最新的，可以获选为leader，任期为4，此时将自己的日志复制到了S3，保证了大多数节点都复制了日志。这里问题来了：此时S1符合commit的条件，那么到底是提交呢还是不提交？ 如果提交，情况为d。提交后，S1崩溃，此时集群中的节点最新的节点为S5（因为尾日志任期最新），并且会进行日志复制，这样的话，就会将之前的任期为2的日志覆盖！这样的话，集群中的节点部分就会缺失term 2的操作！ 其实，实际上需要解决的是，在leader崩溃后，S5这样的节点不能被选为leader！ 如果不提交，情况为e。S1崩溃的话，不会发生上述问题。S1不崩溃的话，在任期4生成日志并复制到大多数节点，然后再提交，这样的话，如果此时S1崩溃，S5并不能当选（想想为什么），因此解决了问题。 客户端交互 支持线性化语义 客户端请求 -&gt; 任一服务器，非 leader 则会转发 leader 崩溃？超时重发。这样会有幂等性问题（使用序列号解决） 只读的操作，可以不需要记录日志，但也会有问题：脏读（可能产生了新的 leader） 脏读解决方式：心跳 ReadIndex or 租约 lease ReadIndex 与其他的节点发心跳，肯定自己为 leader lease 取一个小于 Election Timeout的时间作为租期 租期内不发生选举 非常依赖时间，不能有太大的误差 Have a try动手实现Raft：https://pdos.csail.mit.edu/6.824/labs/lab-raft.html 参考https://raft.github.io/https://raft.github.io/raft.pdfhttps://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.mdhttps://pingcap.github.io/blog-cn/linearizability-and-raft/http://homepage.divms.uiowa.edu/~ghosh/16612.week11.pdfhttps://en.wikipedia.org/wiki/Consensus_(computer_science)) 董峻铎，于2019年8月29日，小米武汉","tags":[]},{"title":"6.828-2018-Lecture-1:O/S overview","date":"2019-02-17T18:44:13.000Z","path":"2019/02/18/6-828-2018-Lecture-1-O-S-overview/","text":"6.828 2018 Lecture 1: O/S overview16.828 2018 课时1:操作系统概述 Overview1概述 6.828 goals Understand operating system design and implementation Hands-on experience by building small O/S123* 6.828 课程目标* 理解操作系统的设计与实现* 通过构建小的操作系统来亲自动手实践 What is the purpose of an O/S? Support applications Abstract the hardware for convenience and portability Multiplex the hardware among multiple applications Isolate applications in order to contain bugs Allow sharing among applications Provide high performance1234567* 操作系统的作用是什么? * 支持应用运行 * 将硬件层抽象,提供方便和可移植性 * 在多个应用之间提供硬件资源复用 * 隔离多个应用,容许错误存在 * 允许应用之间共享资源 * 提供较高的性能 What is the O/S design approach? the small view: a h/w management library the big view: physical machine -&gt; abstract one w/ better properties123* 操作系统设计的方法是什么? * 从小的角度来看:一个硬件管理库 * 从大的角度来看:物理机器到有着较好的性能的抽象单元的一个映射 Organization: layered picture &emsp;h/w: CPU, mem, disk, &amp;c &emsp;kernel services &emsp;user applications: vi, gcc, &amp;c we care a lot about the interfaces and internal kernel structure12345* 操作系统的组织:分层图 硬件层:CPU(中央处理单元),内存,磁盘,等等 内核服务 用户应用层:vi,gcc,等等 * 我们比较关心接口和内部内核结构 What services does an O/S kernel typically provide? processes memory allocation file contents directories and file names security many others: users, IPC, network, time, terminals1234567* 操作系统提供哪些有特点的服务? * 进程 * 内存分配 * 文件内容 * 目录和文件名 * 安全 * 很多其他的服务:用户,IPC(进程间通信),网络,时间,终端. What does an O/S abstraction look like? Applications see them only via system calls Examples, from UNIX (e.g. Linux, OSX, FreeBSD): fd = open(&quot;out&quot;, 1); write(fd, &quot;hello\\n&quot;, 6); pid = fork(); 1234567* 操作系统完成的抽象是什么样子的? * 应用只能通过系统调用来访问它们 * 例如, 在UNIX下 (比如 Linux, OSX, FreeBSD): fd = open(&quot;out&quot;, 1); write(fd, &quot;hello\\n&quot;, 6); pid = fork(); Why is O/S design/implementation hard/interesting? the environment is unforgiving: quirky h/w, weak debugger it must be efficient (thus low-level?)…but abstract/portable (thus high-level?) powerful (thus many features?)…but simple (thus a few composable building blocks?) features interact: fd = open(); ...; fork() behaviors interact: CPU priority vs memory allocator open problems: security; performance; exploiting new hardware123456789* 为什么操作系统的设计和实现非常困难而且有意思? * 不要忘记工作环境:古怪的硬件设备,功能弱小的调试工具 * 它必须得有效率(因此是底层?) ...但是也需要一定抽象和可移植(因此是上层?) * 功能强大 ...但是简单(因此有一些可组合的构建块?) * 很有特点的交互方式: `fd = open(); ...; fork()` * 行为交互方式: CPU优先级 vs 内存管理器 * 开放问题:安全,性能,开发新硬件 You’ll be glad you learned about operating systems if you… want to work on the above problems care about what’s going on under the hood have to build high-performance systems need to diagnose bugs or security problems12345* 学习操作系统你将会很开心,如果你... * 想要从事于上述问题 * 关心在&quot;头巾&quot;下面到底发生了什么 * 必须构建高性能的系统 * 需要诊断错误(bugs)或安全问题 Class structure1课程结构 See web site: https://pdos.csail.mit.edu/6.828 1具体查看网站: https://pdos.csail.mit.edu/6.828 Lectures O/S ideas detailed inspection of xv6, a traditional O/S xv6 programming homework to motivate lectures papers on some recent topics12345* 课程讲座 * 操作系统相关概念 * 针对xv6, 一种经典的操作系统进行详细查看和学习 * 用xv6编程作业引导和推动课程讲座 * 近年一些相关主题的论文 Labs: JOS, a small O/S for x86 in an exokernel style you build it, 5 labs + final lab of your choice kernel interface: expose hardware, but protect – few abstractions! unprivileged user-level library: fork, exec, pipe, … applications: file system, shell, .. development environment: gcc, qemu lab 1 is out1234567* 实验: JOS, 一个小的应用于x86架构的exokernel风格的操作系统 * 你来构建它,通过5个课内实验和一个你选择的最终实验完成 * 内核接口:暴露硬件,但是仍要保护起来--几乎没有抽象! * 无特权的用户层次库:fork,exec,pipe,... * 应用: 文件系统, shell, .. * 开发环境: gcc, qemu * lab 1 已经发放 (demo: build JOS and run ls) 1(示例:构建JOS并且运行ls命令) Xv6 and JOSTwo different designsHopefully will force you understand issues better, but will be confusing tooNeither has the complexity of a real OS(demo: build Linux) 12345* Xv6和JOS 两种不同的设计 希望能够促使你更好地理解问题,但是也会带来困惑 也不会有一个真正的操作系统的复杂 (示例: 构建Linux) Two exams: midterm during class meeting, final in finals week Introduction to system calls1有关系统调用的介绍 6.828 is largely about design and implementation of system callinterface. let’s look at how programs use that interface.we’ll focus on UNIX (Linux, Mac, POSIX, &amp;c). 12* 6.828很大一部分是关于设计和实现系统调用接口. 让我们来看看程序是如何使用该接口的.我们将关注类UNIX系统(Linux, Mac, POSIX, 等等). a simple example: what system calls does “ls” call? Trace system calls: On OSX: sudo dtruss /bin/ls On Linux: strace /bin/ls so many system calls!12345* 一个简单的例子: &quot;ls&quot;调用了哪些系统调用? * 追踪调用的系统调用 * 在OSX: sudo dtruss /bin/ls * 在Linux: strace /bin/ls * 太多太多系统调用了! example: copy input to outputcat copy.ccc -o copy copy.c./copyread a line, then write a linenote: written in C, the traditional O/S language first read/write argument is a “file descriptor” (fd)passed to kernel to tell it what “open file” to read/writemust previously have been opened, connects to file/device/socket/&amp;cUNIX convention: fd 0 is “standard input”, 1 is “standard output” sudo dtruss ./copyread(0x0, “123\\n\\0”, 0x80) = 4 0write(0x1, “123\\n@\\213\\002\\0”, 0x4) = 4 0 123456789101112131415* 示例:将输入拷贝至输出 cat copy.c cc -o copy copy.c ./copy 读一行,然后写一行 注意:用编写传统操作系统的语言--C语言来编写 * 第一个 读/写 参数是一个&quot;文件描述元&quot;(fd) 传递给内核来告诉它是什么&quot;已打开的文件&quot;需要读/写操作 文件必须要提前已经被打开, 连接到file/device/socket/等等 UNIX约定: fd 0 是&quot;标准输入&quot;, 1 is &quot;标准输出&quot; * sudo dtruss ./copy read(0x0, &quot;123\\n\\0&quot;, 0x80) = 4 0 write(0x1, &quot;123\\n@\\213\\002\\0&quot;, 0x4) = 4 0 example: creating a filecat open.ccc -o open open.c./opencat output.txtnote: creat() turned into open()note: can see actual FD with dtrussnote: this code ignores errors – don’t be this sloppy! 12345678* 示例: 新建一个文件 cat open.c cc -o open open.c ./open cat output.txt 注意: creat()变为了open() 注意: 可以通过dtruss查看到真实的FD 注意: 这段代码忽略了错误--可不能这么粗心! example: redirecting standard outputcat redirect.ccc -o redirect redirect.c./redirectcat output.txtman dup2sudo dtruss ./redirectnote: writes output.txt via fd 1note: stderr (standard error) is fd 2 – that’s why creat() yields FD 3 123456789* 示例:重定向标准输出 cat redirect.c cc -o redirect redirect.c ./redirect cat output.txt man dup2 sudo dtruss ./redirect 注意: 通过fd 1写入output.txt 注意: stderr (标准错误) 是 fd 2 -- 这就是为什么 creat() 产生了 FD 3 a more interesting program: the Unix shell. it’s the Unix command-line user interface it’s a good illustration of the UNIX system call API some example commands:lsls &gt; junkls | wc -lls | wc -l &gt; junk the shell is also a programming/scripting languagecat &gt; script &emsp;echo one &emsp;echo twosh &lt; script the shell uses system calls to set up redirection, pipes, waitingprograms like wc are ignorant of input/output setup123456789101112131415* 一个更有意思的程序: the Unix shell. * 它是Unix系统的命令行用户接口 * 对于UNIX系统调用API,它是一个很好的举例 * 一些示例命令: ls ls &gt; junk ls | wc -l ls | wc -l &gt; junk * shell还是一种程序/脚本语言 cat &gt; script echo one echo two sh &lt; script * shell使用系统调用来启动重定向, 管道, 等待 程序如wc对于输入/输出的启动是不知晓的 Let’s look at source for a simple shell, sh.c 1让我们来看看一个简易的shell源代码文件,sh.c main()basic organization: parse into tree, then runmain process: getcmd, fork, waitchild process: parsecmd, runcmdwhy the fork()? &emsp;we need a new process for the commandwhat does fork() do? &emsp;copies user memory &emsp;copies kernel state e.g. file descriptors &emsp;so “child” is almost identical to “parent” &emsp;child has different “process ID” &emsp;both processes now run, in parallel &emsp;fork returns twice, once in parent, once in child &emsp;fork returns child PID to parent &emsp;fork returns 0 to child &emsp;so sh calls runcmd() in the child processwhy the wait()?what if child exits before parent calls wait()? 123456789101112131415161718* main() basic organization: parse into tree, then run main process: getcmd, fork, wait child process: parsecmd, runcmd why the fork()? we need a new process for the command what does fork() do? copies user memory copies kernel state e.g. file descriptors so &quot;child&quot; is almost identical to &quot;parent&quot; child has different &quot;process ID&quot; both processes now run, in parallel fork returns twice, once in parent, once in child fork returns child PID to parent fork returns 0 to child so sh calls runcmd() in the child process why the wait()? what if child exits before parent calls wait()? runcmd()executes parse tree generated by parsecmd()distinct cmd types for simple command, redirection,pipe runcmd() for simple command with argumentsexecvp(cmd, args)man execvpls command &amp;c exist as executable files, e.g. /bin/lsexecvp loads executable file over memory of current processjumps to start of executable – main()note: execvp doesn’t return if all goes wellnote: execvp() only returns if it can’t find the executable filenote: it’s the shell child that’s replaced with execvp()note: the main shell process is still wait()ing for the child how does runcmd() handle I/O redirection?e.g. echo hello &gt; junkparsecmd() produces tree with two nodes &emsp;cmd-&gt;type=’&gt;’, cmd-&gt;file=”junk”, cmd-&gt;cmd=… &emsp;cmd-&gt;type=’ ‘, cmd-&gt;argv=[“echo”, “hello”]the open(); dup2() causes FD 1 to be replaced with FD to output fileit’s the shell child process that changes its FD 1execvp preserves the FD setupso echo runs with FD 1 connected to file junkagain, very nice that echo is oblivious, just writes FD 1 why are fork and exec separate?perhaps wasteful that fork copies shell memory, only to have it thrown away by execthe point: the child gets a chance to change FD setup before calling execand the parent’s FD set is not disturbedyou’ll implement tricks to avoid fork() copy cost in the labs how does the shell implement pipelines?$ ls | wc -l the kernel provides a pipe abstractionint fds[2]pipe(fds)a pair of file descriptors: a write FD, and a read FDdata written to the write FD appears on the read FD example: pipe1.cread() blocks until data is availablewrite() blocks if pipe buffer is full pipe file descriptors are inherited across forkso pipes can be used to communicate between processesexample: pipe2.cfor many programs, just like file I/O, so pipes work for stdin/stdout for ls | wc -l, shell must: create a pipe fork set up fd 1 to be the pipe write FD exec ls set up wc’s fd 0 to be pipe read FD exec wc wait for wc[diagram: sh parent, sh child, ls grandchild, wc grandchild, stdin/out for each]case ‘|’ in sh.cnote: sh close()es unused FDs &amp;emsp;so exit of writer produces EOF at reader you’ll implement pieces of a shell in an upcoming homework","tags":[]},{"title":"Assignment for Stanford CS143:Compilers","date":"2019-01-20T10:50:38.000Z","path":"2019/01/20/Assignment-for-Stanford-cs143-Compilers/","text":"Preface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大三上半年这个学期,学校开设了编译原理这门课程,使用的是 Stanford CS143这门课的课件来教授.尽管如此,因为课时的原因,很多关于这门课的精华部分点到为止,而且这门课最具特色的实习我们也没有完成.这个假期,我想找空闲时间,完成这门课程的5次实习,把自己学习到的编译原理的知识应用一下. Introduction to Stanford CS143&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这门课程在 Coursera 上也有公开课程,不过我这里还是使用了 Stanford 课程官网上的课件来学习.这门课程的历史很久, Assignment 也在不断变化,之前的课程(2012年之前)要求实现的是一种名叫’ Decaf ‘的语言,可以找到相应的学习资料在该历史网址,后面课程更新后,实现的是一种名叫 Cool 的语言.关于这门语言的介绍在Wikipedia)和语言官网上可以找到. Cool Language&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wikipedia 上针对 Cool 语言的解释为: an acronym for Classroom Object Oriented Language, is a computer programming language designed by Alexander Aiken for use in an undergraduate compiler course project. 即是一种用于教学使用的面向对象语言.对于该门语言官网上解释来说, Cool is a small language designed for use in an undergraduate compiler course project. While small enough for a one term project, Cool still has many of the features of modern programming languages(有很多现代编程语言的特点), including objects(对象), automatic memory management(动态内存管理), and strong static typing(强静态类型). Cool is built entirely on public domain tools; it generates code for a MIPS simulator, spim (产生MIPS汇编代码). Thus, the project should port easily to other platforms(跨平台). The project has been used for teaching compilers at many institutions and the software is stable. About Assignment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上给出了 Cool 语言的各种介绍链接,包含针对于 assignment 需要使用的工具文档,如 Flex,Bison .该课程包含5次 program assignment ,分块实现 Cool 语言. Stanford 针对上机教学环境有自己搭建的教学资源服务器,很多需要的软件运行环境我们是访问不到的,需要自己手动配置.不过,针对于这门课放出了软件运行环境供我们下载使用.该资源为 virtual box 虚拟机,环境系统为Linux,关于课程所需要的环境已经部署好,我们可以将文件copy至virtual box打开,使用虚拟机完成实习.对我来说的话,本身有现成的Linux环境,虚拟机太慢了,我直接从虚拟机中将文件copy出来放在自己的Linux系统中(给出的Linux虚拟环境太老了,很多https网站内置浏览器不能访问,实在是满足不了需求).当然,环境迁移的教程官网上都有详细说明. The End&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前环境已经搭建完毕,紧接着按5次 assignment 来实现.后面的文章分块儿讲述自己的实现过程,也是在不断地督促自己高效率完成.新的学习任务,给自己一点动力,用 Cool 语言写一句祝福为自己加油打气: code result","tags":[{"name":"cs143","slug":"cs143","permalink":"http://andj.me/tags/cs143/"},{"name":"compiler","slug":"compiler","permalink":"http://andj.me/tags/compiler/"},{"name":"cool","slug":"cool","permalink":"http://andj.me/tags/cool/"},{"name":"assignment","slug":"assignment","permalink":"http://andj.me/tags/assignment/"}]},{"title":"搭建多端编写hexo博客环境","date":"2018-12-24T19:44:29.000Z","path":"2018/12/25/搭建多端编写hexo博客环境/","text":"Preface这是一篇指导搭建多端编写Hexo博客环境的文章。所谓多端搭建，是指本地已经搭建好了Hexo博客，并且能够部署至服务器，但是如果换一台PC，则没有该博客部署需要的源代码文件，博客就必须重建。因此需要让博客编写环境多端搭建，使便于博客编写环境迁移，避免出现因重置系统、文件丢失等因素造成博客无法继续的问题。 Start With Windows 10系统下搭建完成hexo环境 基本软件安装完成: git, node.js 博客已部署至 github 计划迁移环境：Linux，测试系统为 deepin 15.8Plan一、Github保存代码文件为了让环境迁移，首先必须保存代码文件，将博客所有文件放在Github远程仓库里面，基于这些文件我们可以在其他平台上重建博客编写环境。注意hexo搭建的博客文件夹下有.gitignore，该文件即github上传时需要忽略的文件，默认如下：1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 这些文件也都是重建博客不需要的文件，剩下的都是必须文件，这里给出我上传备份的文件：123456scaffolds/*source/*themes/*.gitignore_config.ymlpackage.json 这里不再赘述文件夹上传，保存即可，该代码库记为 Blog。 二、迁移环境搭建目标迁移环境系统为deepin 15.8 安装node.js环境 选择合适的安装位置，这里安装位置为 ~/Softwares 1andj@deepin:~/Softwares$ wget https://nodejs.org/dist/v8.9.4/node-v8.9.4-linux-x64.tar.xz 解压该文件并更名node.js： 12andj@deepin:~/Softwares$ tar -zxvf node-v8.9.4-linux-x64.tar.xzandj@deepin:~/Softwares$ mv node-v8.9.4-linux-x64 node.js 将node.js/bin环境配置入环境变量： 1234andj@deepin:~/Softwares$ sudo vim /etc/profile 文件中添加: PATH=/home/andj/Softwares/node.js/bin:$PATHandj@deepin:~/Softwares$ source /etc/profile 配置hexo 下载之前上传的hexo源代码文件到合适位置： 1andj@deepin:~/Project$ git clone git@github.com:XXX/Blog.git 切入博客文件下安装hexo 1andj@deepin:~/Project$ npm install hexo-cli -g 初始化环境 1andj@deepin:~/Project$ npm install 这里注意不需要hexo init，因为主要文件已经存在，不需要完全重置。 测试搭建的环境 创建新博文 1andj@deepin:~/Project$ hexo create &quot;test&quot; 针对该博文做出修改 12andj@deepin:~/Project/Blog$ cd source/_postandj@deepin:~/Project/Blog/source/_post/$ vim test 退回原根目录进行部署 123andj@deepin:~/Project/Blog/source/_post/$ cd ../..andj@deepin:~/Project/Blog/$ hexo gandj@deepin:~/Project/Blog/$ hexo d 查看网页是否搭建成功 Reference使用hexo，如果换了电脑怎么更新博客？","tags":[{"name":"hexo","slug":"hexo","permalink":"http://andj.me/tags/hexo/"},{"name":"environment","slug":"environment","permalink":"http://andj.me/tags/environment/"},{"name":"blog","slug":"blog","permalink":"http://andj.me/tags/blog/"}]},{"title":"LuoGu_1056_1328_1563","date":"2018-09-02T17:37:29.000Z","path":"2018/09/03/LuoGu-1056-1328-1563/","text":"P1056 排座位题目入口 这道题的算法标签是 贪心 和 排序 。这道题的背景很有意思，给出了班级的整体布局，给出了班级内上课交流的同学的相邻坐标，同时也给出了针对班级行和列需要规划的过道数。从理想状况来看，当然是把每一个同学和其他所有同学完全隔离开，即可避免任何两个同学之前上课交流，但是偏偏题目中有限制，隔离的行列必须是题目测试数据给出的指定值，不能随意设置隔道进行隔离。 那么这道题的思路就变成一个求解最优解问题，即选择有限个隔道的分布位置，尽可能多地分开交流的同学对数。这里用到了贪心的思想，贪心策略是：每次选择所有相邻的两行（列）中 交头接耳的同学对 最多的那一行（列）设置通道隔开。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//P1056 排座位#include &lt;bits/stdc++.h&gt;using namespace std;//row and column 行和列int row[1001];int column[1001];bool r[1001];bool c[1001];int main()&#123; int m,n,k,l,d; cin&gt;&gt;m&gt;&gt;n&gt;&gt;k&gt;&gt;l&gt;&gt;d; int x,y,p,q; for(int i=0;i&lt;d;i++)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;p&gt;&gt;q; if(x==p) column[y&lt;q?y:q]++; else row[x&lt;p?x:p]++; &#125; for(int i=1;i&lt;=k;i++)&#123; int maxx=-1; int pos=0; for(int j=1;j&lt;m;j++)&#123; if(row[j]&gt;maxx)&#123; maxx=row[j]; pos=j; &#125; &#125; r[pos]++; row[pos]=0; &#125; for(int i=1;i&lt;=l;i++)&#123; int maxx=-1; int pos=0; for(int j=1;j&lt;n;j++)&#123; if(column[j]&gt;maxx)&#123; maxx=column[j]; pos=j; &#125; &#125; c[pos]++; column[pos]=0; &#125; for(int i=0;i&lt;1001;i++)&#123; if(r[i]!=0) cout&lt;&lt;i&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(int i=0;i&lt;1001;i++)&#123; if(c[i]!=0) cout&lt;&lt;i&lt;&lt;\" \"; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344//P1328 生活大爆炸版石头剪刀布#include &lt;bits/stdc++.h&gt;using namespace std;int judge[5][5];int a[201];int b[201];int main()&#123; judge[0][0]=0;judge[0][1]=-1;judge[0][2]=1;judge[0][3]=1;judge[0][4]=-1; judge[1][1]=0;judge[1][2]=-1;judge[1][3]=1;judge[1][4]=-1; judge[2][2]=0;judge[2][3]=-1;judge[2][4]=1; judge[3][3]=0;judge[3][4]=1; judge[4][4]=0; int n,na,nb; cin&gt;&gt;n&gt;&gt;na&gt;&gt;nb; for(int i=0;i&lt;na;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;nb;i++)&#123; cin&gt;&gt;b[i]; &#125; int ca=0,cb=0; int pa=0,pb=0; int r=0; for(int i=0;i&lt;n;i++)&#123; if(pa==na) pa=0; if(pb==nb) pb=0; r=a[pa]&lt;=b[pb]?judge[a[pa]][b[pb]]:-judge[b[pb]][a[pa]]; if(r==1)&#123; ca++; &#125;else if(r==-1)&#123; cb++; &#125; pa++; pb++; &#125; cout&lt;&lt;ca&lt;&lt;\" \"&lt;&lt;cb; return 0;&#125; 123456789101112131415161718192021222324252627282930//P1563 玩具谜题#include &lt;bits/stdc++.h&gt;using namespace std;char people[100000][11];int direction[100000];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;direction[i]; scanf(\"%s\",people[i]); &#125; int a,s; int p=0; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;s; if((a==0 &amp;&amp; direction[p]==1)||(a==1 &amp;&amp; direction[p]==0))&#123; p+=s; p%=n; &#125;else if((a==0 &amp;&amp; direction[p]==0)||(a==1 &amp;&amp; direction[p]==1))&#123; p-=s; p+=n; p%=n; &#125; &#125; cout&lt;&lt;people[p]; return 0;&#125;","tags":[{"name":"洛谷1056","slug":"洛谷1056","permalink":"http://andj.me/tags/洛谷1056/"},{"name":"洛谷1328","slug":"洛谷1328","permalink":"http://andj.me/tags/洛谷1328/"},{"name":"洛谷1563","slug":"洛谷1563","permalink":"http://andj.me/tags/洛谷1563/"}]},{"title":"督促自己学习《算法艺术与信息学竞赛》","date":"2018-07-29T22:25:31.000Z","path":"2018/07/30/督促自己学习《算法艺术与信息学竞赛》/","text":"督促自己学习《算法艺术与信息学竞赛》&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机科学(CS)这个专业，算法能力是尤为看重的，尤其是现在，人工智能、区块链、机器学习等热门话题不仅活跃在我们CS圈内，还成为了全社会的关注焦点。不管这些新兴技术今后发展如何，单纯就技术而言，它是无罪的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，学生时代，我们仍可以有环境 “两耳不闻窗外事，一心只读圣贤书”。我创建这个属于自己的博客，即是记录自己平时的点点滴滴，也是想借这个机会，能让我有所产出。上大学这两年，我给自己平添的许多的烦恼，给自己强行贴上了很多的标签，希望自己能尽快在自己的专业上获得进步，少了之前潜下心来做学问的忍耐。手机中各种新闻渠道每天对我狂轰滥炸，光是新闻，微博，微信公众号足以让我花费数个小时阅读积攒下来的文章。之前总是在安慰自己，多点开花才能结果，不要把鸡蛋放在同一个篮子里，现在想来是心思越来越难以集中思考，大部分时间都只是在 “接受”， 从未有有价值的产出。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题症结所在已经找到，我便把手机中这些软件统统删去，给自己保留了尽可能少而有价值的一两个软件作为自己的新闻和知识来源。那么腾出的时间，我便能够专心做自己感兴趣的事情，做自己的学问。这也就是为什么我开启了自己的读书计划——《算法艺术与信息学竞赛》。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我高中并没有搞OI竞赛，现在也没有系统地学习ACM，站在这本书面前，我只作为一名单纯的算法竞赛爱好者去学习，有机会的话，我也希望自己能够在ACM历练一下。尤其是现在各大OJ平台非常完善，能够在自己的学习之余不断练习，单是因为兴趣，总能找到志同道合的伙伴给出漂亮的Solution。算法竞赛练习既是自己的课余兴趣，也能够通过这个锻炼自己，在今后的学习和研究中打开思路。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《算法艺术与信息学竞赛》这本书是刘汝佳的经典之作，OI圈的人成为传说中的 “黑书”。我第一次见到这本书，是在高中时一个搞OI的舍友拿着它激动万分地和我说有人赠送给他这本传说中的黑书，当然这位舍友也是神人，最终进入国家集训队，保送清华大学。机缘巧合，我在校图书馆见到了这本书，馆藏只有两本。这本书定位并不是针对新人，而是给竞赛选手提升经验的。内容上看，这本书代码和伪代码都不多，大体上是从思路上进行展开，基本上是纯思路的讲解，因此一定的领悟之上配合更多的练习是必要的。这本书再版后面对新人更加的友好，但是深度也打了一定的折扣，能拿到的这本书已经是绝版了，官方网站已经停止维护，随书在官网上附赠的资料也已经很难找到。不过也正是因为这本书有难度，自己才有了啃的兴趣。万幸的是，在CSDN上有圈内人提供了这本书的PDF版以及随书的很多资料，在本文末贴了出来。如果失效，请给我留言，以便我及时做出更新。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跟随我这本书学习的，当然少不了圣经 CLRS。CLRS的学习我注重于笔记，也会分享自己的学习文章，方便今后出现合适的机会重新学习。这篇文章，权当是给自己一个鼓励，一个督促。“万事开头难”，希望自己能够坚持下去，用心做自己感兴趣的事情。 下载地址","tags":[]}]